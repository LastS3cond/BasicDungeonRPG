<html>

<head></head>

<body>
	<canvas id="maze" width="1200" height="1200"></canvas>
	<canvas id="manual" width="1200" height="1200"></canvas>
	<script src="writeFile.js"></script>
	<script>
		var s = 423;
		var size, delta, maze, mazeSize, startRow, startCol, endRow, endCol;
		var canvasTop = document.getElementById("maze");
		var canvasBot = document.getElementById("manual");
		var ctx = canvasTop.getContext("2d");
		var ctx2 = canvasBot.getContext("2d");
		canvasTop.width = s * 3; canvasTop.height = 423;
		canvasBot.width = s * 3; canvasBot.height = 130;
		mazeSize = 9;
		delta = s / mazeSize;
		maze = Maze(mazeSize * 3, mazeSize);
		var locR = startRow;
		var locC = startCol;
		let gateCounter = 0;
		document.addEventListener("keydown", move);
		write("Collect all dark blue keys to unlock the dark red doors/Game is finished when you find the red exit/Use WASD controls or arrow keys".toUpperCase(), ctx2, 3);

		function Maze(row, col) {
			let endNotFound = true;
			let maze = new Array(col);
			for (let i = 0; i < maze.length; i++)
				maze[i] = new Array(row);
			let pathRow = [];
			let pathCol = [];
			let possibleOps = [];
			var r, c, south, east, north, west, rndm;
			for (r = 0, c = 0; r < maze.length; r++)
				maze[r][c] = -3;
			for (r = 0, c = maze[0].length - 1; r < maze.length; r++)
				maze[r][c] = -3;
			for (r = 0, c = 1; c < maze[0].length; c++)
				maze[r][c] = -3;
			for (r = maze.length - 1, c = 1; c < maze[0].length; c++)
				maze[r][c] = -3;
			startCol = 0;
			endCol = maze[0].length - 1;
			startRow = 1 + 2 * Math.floor(Math.random() * (maze.length - 2) / 2);
			endRow = 1 + 2 * Math.floor(Math.random() * (maze.length - 2) / 2);
			maze[startRow][startCol] = -6;
			maze[endRow][endCol] = -5;
			while (endNotFound) {
				for (r = 1; r < maze.length - 1; r++)
					for (c = 1; c < maze[0].length - 1; c++)
						maze[r][c] = 0;
				for (r = 2; r < maze.length - 2; r += 2)
					for (c = 2; c < maze[0].length - 2; c += 2)
						maze[r][c] = -3;
				spotConvert(maze, startRow, startCol + 1);
				pathRow.push(startRow);
				pathCol.push(startCol + 1);
				maze[endRow][endCol - 1] = -4;
				let counter = 0;
				while (!(pathRow.length == 0)) {
					if (Math.floor(Math.random() * 3) == 0) {
						pathRow = pathRow.reverse();
						pathCol = pathCol.reverse();
					}
					south = spotCheck(maze, pathRow[pathRow.length - 1] + 1, pathCol[pathCol.length - 1]);
					east = spotCheck(maze, pathRow[pathRow.length - 1], pathCol[pathCol.length - 1] + 1);
					north = spotCheck(maze, pathRow[pathRow.length - 1] - 1, pathCol[pathCol.length - 1]);
					west = spotCheck(maze, pathRow[pathRow.length - 1], pathCol[pathCol.length - 1] - 1);
					if (south == 0 || east == 0 || north == 0 || west == 0) {
						endNotFound = false;
						spotConvert(maze, endRow, endCol - 1);
					}
					else {
						if (south == 2)
							possibleOps.push('s');
						if (east == 2)
							possibleOps.push('e');
						if (north == 2)
							possibleOps.push('n');
						if (west == 2)
							possibleOps.push('w');
						if (possibleOps.length > 0) {
							rndm = Math.floor(Math.random() * possibleOps.length);
							if (possibleOps[rndm] == 's') {
								pathRow.push(pathRow[pathRow.length - 1] + 1);
								pathCol.push(pathCol[pathCol.length - 1]);
							}
							else if (possibleOps[rndm] == 'e') {
								pathRow.push(pathRow[pathRow.length - 1]);
								pathCol.push(pathCol[pathCol.length - 1] + 1);
							}
							else if (possibleOps[rndm] == 'n') {
								pathRow.push(pathRow[pathRow.length - 1] - 1);
								pathCol.push(pathCol[pathCol.length - 1]);
							}
							else {
								pathRow.push(pathRow[pathRow.length - 1]);
								pathCol.push(pathCol[pathCol.length - 1] - 1);
							}
							spotConvert(maze, pathRow[pathRow.length - 1], pathCol[pathCol.length - 1]);
							possibleOps.splice(0, possibleOps.length)
						}
						else {
							eventSpotCheck(maze, pathRow[pathRow.length - 1], pathCol[pathCol.length - 1])
							pathRow.pop();
							pathCol.pop();
						}
					}
				}
			}
			generateDoors(maze);
			return mazeConversion(maze);
		}
		function generateDoors(m) {
			let solution = solveMaze(m);
			let row = [];
			let column = [];
			let rowT = [];
			let colT = [];
			for (let i = 0; !solution.length == 0; i++) {
				row.push(solution.shift());
				column.push(solution.shift());
			}
			let doorR = [];
			let doorC = [];
			console.log(row);
			console.log(column);
			let counter = 0;

			while (row.length != 0) {
				if (counter > 1) {
					m[row.pop()][column.pop()] = -100 - counter;
					counter = 0;
				}
				let r = row.pop()
				let c = column.pop()
				rowT.push(r);
				colT.push(c);
				while (rowT.length != 0) {
					if (m[r][c] == -7)
						counter++;
					else {
						if (m[r + 1][c] == -1 || m[r + 1][c] == -7) {
							colT.push(c);
							rowT.push(r + 1);
						}
						if (m[r - 1][c] == -1 || m[r - 1][c] == -7) {
							colT.push(c);
							rowT.push(r - 1);
						}
						if (m[r][c + 1] == -1 || m[r][c + 1] == -7) {
							colT.push(c + 1);
							rowT.push(r);
						}
						if (m[r][c - 1] == -1 || m[r][c - 1] == -7) {
							colT.push(c - 1);
							rowT.push(r);
						}
						m[r][c] = -20;
					}
					r = rowT.pop();
					c = colT.pop();
				}

			}
			for (r = 0; r < m.length; r++) {
				for (c = 0; c < m[0].length; c++) {
					if (m[r][c] == -20) {
						m[r][c] = -1;
					}
				}
			}
			console.log(m);
		}
		function solveMaze(maze) //Uses Stack to satisfy postconditon
		{
			let m = maze;
			let row = [];
			let column = [];
			let r = startRow;
			let c = startCol + 1;
			for (; ;) {
				if (m[r][c] == -1) {
					column.push(c);
					row.push(r);
				}
				if (m[r][c] == -10 || m[r][c] == -1) {
					m[r][c] = -20;
					if (m[r][c + 1] == -1 || m[r][c + 1] == -5)
						c++;
					else if (m[r][c - 1] == -1 || m[r][c - 1] == -5)
						c--;
					else if (m[r + 1][c] == -1 || m[r + 1][c] == -5)
						r++;
					else if (m[r - 1][c] == -1 || m[r][c + 1] == -5)
						r--;
				}
				else if (m[r][c] == -5) {
					for (c = 0; c < m[0].length; c++) {
						for (r = 0; r < m.length; r++) {
							if (m[r][c] == -10)
								m[r][c] = -1;
						}
					}
					break;
				}
				else {
					if (column.length == 0)
						break;
					column.pop();
					row.pop();
					m[r][c] = -10;
					c = column[column.length - 1];
					r = row[row.length - 1];
					m[r][c] = -10;
				}
			}
			let solution = [];
			for (let i = 0; !row.length == 0; i++) {
				solution.push(row.pop());
				solution.push(column.pop());
			}
			return solution;
		}
		function eventSpotCheck(maze, row, col) {
			if (maze[row + 1][col] == -3) {
				if (maze[row - 1][col] == -3) {
					if (maze[row][col - 1] >= 2) {
						maze[row][col - 1] = -7;
						maze[row][col] = -1;
						maze[row + 1][col - 1] = 2;
						maze[row - 1][col - 1] = 2;
						maze[row][col - 2] = 2;
						return false;
					}
					else if (maze[row][col + 1] >= 2) {
						maze[row][col + 1] = -7;
						maze[row][col] = -1;
						maze[row + 1][col + 1] = 2;
						maze[row - 1][col + 1] = 2;
						maze[row][col + 2] = 2;
						return false;
					}
				}
			}
			else if (maze[row][col + 1] == -3) {
				if (maze[row][col - 1] == -3) {
					if (maze[row - 1][col] >= 2) {
						maze[row - 1][col] = -7;
						maze[row][col] = -1;
						maze[row - 1][col + 1] = 2;
						maze[row - 1][col - 1] = 2;
						maze[row - 2][col] = 2;
						return false;
					}
					else if (maze[row + 1][col] >= 2) {
						maze[row + 1][col] = -7;
						maze[row][col] = -1;
						maze[row + 1][col + 1] = 2;
						maze[row + 1][col - 1] = 2;
						maze[row + 2][col] = 2;
						return false;
					}
				}
			}
			if (Math.floor(Math.random() * 2) == 0) {
				let v = 0;
				if (maze[row + 1][col] == -3 || maze[row + 1][col] >= 0)
					v++;
				if (maze[row][col + 1] == -3 || maze[row][col + 1] >= 0)
					v++;
				if (maze[row - 1][col] == -3 || maze[row - 1][col] >= 0)
					v++;
				if (maze[row][col - 1] == -3 || maze[row][col - 1] >= 0)
					v++;
				if (v >= 3) {
					maze[row][col] = -7;
					return true;
				}
			}
			return false;
		}
		function spotCheck(maze, crow, ccol) {
			if (maze[crow][ccol] == -4)
				return 0;
			else if (maze[crow][ccol] != 0 && maze[crow][ccol] != 1)
				return 1;
			else
				return 2;
		}
		function spotConvert(maze, crow, ccol) {
			maze[crow][ccol] = -1;
			if (maze[crow + 1][ccol] >= 0)
				maze[crow + 1][ccol]++;
			if (maze[crow][ccol + 1] >= 0)
				maze[crow][ccol + 1]++;
			if (maze[crow - 1][ccol] >= 0)
				maze[crow - 1][ccol]++;
			if (maze[crow][ccol - 1] >= 0)
				maze[crow][ccol - 1]++;
		}
		function mazeConversion(maze) {
			ctx.fillStyle = "dimgray";
			for (let r = 0; r < maze.length; r++) {
				for (let c = 0; c < maze[0].length; c++) {
					ctx.fillRect(c * delta, r * delta, delta, delta);
				}
			}
			for (let i = -1; i < 2; i++) {
				for (let j = 0; j < 2; j++) {
					if (maze[startRow + i][startCol + j] >= 0 || maze[startRow + i][startCol + j] == -3)
						ctx.fillStyle = "black";
					else
						ctx.fillStyle = "white";
					ctx.clearRect((startCol + j) * delta, (startRow + i) * delta, delta, delta);
					ctx.fillRect((startCol + j) * delta, (startRow + i) * delta, delta, delta);
				}
			}
			ctx.fillStyle = "blue";
			ctx.fillRect(startCol * delta, startRow * delta, delta, delta);

			return maze;
		}

		function move(e) {
			let key = e.code;
			ctx.fillStyle = "dimgray";
			if ((key == "ArrowUp" || key == "KeyW") && (maze[locR - 1][locC] == "-1" || maze[locR - 1][locC] == "-5" || maze[locR - 1][locC] == "-7")) {
				ctx.clearRect(locC * delta, locR * delta, delta, delta);
				locR--;
				for (let i = -1; i < 2; i++)
					ctx.fillRect((locC + i) * delta, (locR + 2) * delta, delta, delta);
			}
			else if ((key == "ArrowDown" || key == "KeyS") && (maze[locR + 1][locC] == "-1" || maze[locR + 1][locC] == "-5" || maze[locR + 1][locC] == "-7")) {
				ctx.clearRect(locC * delta, locR * delta, delta, delta);
				locR++;
				for (let i = -1; i < 2; i++)
					ctx.fillRect((locC + i) * delta, (locR - 2) * delta, delta, delta);
			}
			else if ((key == "ArrowRight" || key == "KeyD") && (maze[locR][locC + 1] == "-1" || maze[locR][locC + 1] == "-5" || maze[locR][locC + 1] == "-7")) {
				ctx.clearRect(locC * delta, locR * delta, delta, delta);
				locC++;
				for (let i = -1; i < 2; i++)
					ctx.fillRect((locC - 2) * delta, (locR + i) * delta, delta, delta);
			}
			else if ((key == "ArrowLeft" || key == "KeyA") && (maze[locR][locC - 1] == "-1" || maze[locR][locC - 1] == "-5" || maze[locR][locC - 1] == "-7")) {
				ctx.clearRect(locC * delta, locR * delta, delta, delta);
				locC--;
				for (let i = -1; i < 2; i++)
					ctx.fillRect((locC + 2) * delta, (locR + i) * delta, delta, delta);
			}
			for (let i = -1; i < 2; i++) {
				for (let j = -1; j < 2; j++) {
					if (maze[locR + i][locC + j] >= 0 || maze[locR + i][locC + j] == -3)
						ctx.fillStyle = "black";
					else if (maze[locR + i][locC + j] == "-1")
						ctx.fillStyle = "white";
					else if (maze[locR + i][locC + j] == "-6")
						ctx.fillStyle = "deepskyblue";
					else if (maze[locR + i][locC + j] == "-5")
						ctx.fillStyle = "red";
					else if (maze[locR + i][locC + j] == "-7")
						ctx.fillStyle = "midnightblue";
					else if (maze[locR + i][locC + j] <= -100) {
						if (maze[locR + i][locC + j] + 100 + gateCounter == 0) {
							ctx.fillStyle = "white";
							maze[locR + i][locC + j] = -1;
							gateCounter = 0;
						}
						else
							ctx.fillStyle = "darkred";
					}
					ctx.fillRect((locC + j) * delta, (locR + i) * delta, delta, delta);
				}
			}
			if (maze[locR][locC] == -7) {
				maze[locR][locC] = -1;
				eventDungeon();
				gateCounter++;
			}
			ctx.fillStyle = "blue";
			ctx.fillRect(locC * delta, locR * delta, delta, delta);

			if (maze[locR][locC] == "-5") {
				document.removeEventListener("keydown", move);
				endingFound();
			}
		}
		function eventDungeon(dif) {
			let color = []
			for (let i = 0; i < maze.length; i++)
				color[i] = new Array(maze[0].length);

			for (let i = 0; i < maze.length; i++)
				for (let j = 0; j < maze[0].length; j++)
					color[i][j] = ctx.getImageData(j * delta, i * delta, delta, delta);

			for (let r = 0; r < maze.length; r++)
				for (let c = 0; c < maze[0].length; c++)
					ctx.clearRect(c * delta, r * delta, delta, delta);

			Dungeon(dif);

			for (let r = 0; r < maze.length; r++)
				for (let c = 0; c < maze[0].length; c++)
					ctx.clearRect(c * delta, r * delta, delta, delta);

			for (let i = 0; i < maze.length; i++)
				for (let j = 0; j < maze[0].length; j++)
					ctx.putImageData(color[i][j], j * delta, i * delta);
		}
		function Dungeon(dif) {

		}

		function endingFound() {
			ctx.fillStyle = "white";
			for (let r = 0; r < maze.length; r++)
				for (let c = 0; c < maze[0].length; c++)
					ctx.clearRect(c * delta, r * delta, delta, delta);
			ctx.fillStyle = "black";
			delta = s / 30;
			write("CONGRATS!/YOU FOUND /THE END!", ctx, delta);
		}
	</script>
</body>

</html>